///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, ARA::COM Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : otasubscription_skeleton.h
/// SERVICE INTERFACE NAME            : OtaSubscription
/// GENERATED DATE                    : 2025-05-26 16:43:11
///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// CAUTION!! AUTOMATICALLY GENERATED FILE - DO NOT EDIT                                                   
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef PARA_COM_GEN_SERVICE_INTERFACE_OTASUBSCRIPTION_SKELETON_H
#define PARA_COM_GEN_SERVICE_INTERFACE_OTASUBSCRIPTION_SKELETON_H
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @uptrace{SWS_CM_01004}
#include "otasubscription_common.h"
#include "para/com/skeleton/skeleton_interface.h"
/// @uptrace{SWS_CM_01005}
namespace eevp
{
namespace ota
{
namespace subscription
{
namespace service
{
/// @uptrace{SWS_CM_01006}
namespace skeleton
{
class OtaSubscriptionSkeleton;
/// @uptrace{SWS_CM_01009}
namespace events
{
/// @uptrace{SWS_CM_00003}
class notifyAppEvent
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = eevp::ota::subscription::type::RequestAppInfo;
    /// @brief Constructor
    explicit notifyAppEvent(para::com::SkeletonInterface* interface) : mInterface(interface)
    {
    }
    /// @brief Destructor
    virtual ~notifyAppEvent() = default;
    /// @brief Delete copy constructor
    notifyAppEvent(const notifyAppEvent& other) = delete;
    /// @brief Delete copy assignment
    notifyAppEvent& operator=(const notifyAppEvent& other) = delete;
    /// @brief Move constructor
    notifyAppEvent(notifyAppEvent&& other) noexcept : mInterface(other.mInterface)
    {
    }
    /// @brief Move assignment
    notifyAppEvent& operator=(notifyAppEvent&& other) noexcept
    {
        mInterface = other.mInterface;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        para::serializer::Serializer serializer{};
        serializer.write(data);
        auto payload = serializer.ensure();
        return mInterface->SendEvent(kCallSign, payload);
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    const std::string kCallSign = {"notifyAppEvent"};
};
/// @uptrace{SWS_CM_00003}
class notifyResultInfo
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = eevp::ota::subscription::type::resultInfoList;
    /// @brief Constructor
    explicit notifyResultInfo(para::com::SkeletonInterface* interface) : mInterface(interface)
    {
    }
    /// @brief Destructor
    virtual ~notifyResultInfo() = default;
    /// @brief Delete copy constructor
    notifyResultInfo(const notifyResultInfo& other) = delete;
    /// @brief Delete copy assignment
    notifyResultInfo& operator=(const notifyResultInfo& other) = delete;
    /// @brief Move constructor
    notifyResultInfo(notifyResultInfo&& other) noexcept : mInterface(other.mInterface)
    {
    }
    /// @brief Move assignment
    notifyResultInfo& operator=(notifyResultInfo&& other) noexcept
    {
        mInterface = other.mInterface;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        para::serializer::Serializer serializer{};
        serializer.write(data);
        auto payload = serializer.ensure();
        return mInterface->SendEvent(kCallSign, payload);
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    const std::string kCallSign = {"notifyResultInfo"};
};
/// @uptrace{SWS_CM_00003}
class notifyRollbackComplete
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = bool;
    /// @brief Constructor
    explicit notifyRollbackComplete(para::com::SkeletonInterface* interface) : mInterface(interface)
    {
    }
    /// @brief Destructor
    virtual ~notifyRollbackComplete() = default;
    /// @brief Delete copy constructor
    notifyRollbackComplete(const notifyRollbackComplete& other) = delete;
    /// @brief Delete copy assignment
    notifyRollbackComplete& operator=(const notifyRollbackComplete& other) = delete;
    /// @brief Move constructor
    notifyRollbackComplete(notifyRollbackComplete&& other) noexcept : mInterface(other.mInterface)
    {
    }
    /// @brief Move assignment
    notifyRollbackComplete& operator=(notifyRollbackComplete&& other) noexcept
    {
        mInterface = other.mInterface;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        para::serializer::Serializer serializer{};
        serializer.write(data);
        auto payload = serializer.ensure();
        return mInterface->SendEvent(kCallSign, payload);
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    const std::string kCallSign = {"notifyRollbackComplete"};
};
/// @uptrace{SWS_CM_00003}
class notifySwClusterInfo
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = eevp::ota::subscription::type::swClusterInfoList;
    /// @brief Constructor
    explicit notifySwClusterInfo(para::com::SkeletonInterface* interface) : mInterface(interface)
    {
    }
    /// @brief Destructor
    virtual ~notifySwClusterInfo() = default;
    /// @brief Delete copy constructor
    notifySwClusterInfo(const notifySwClusterInfo& other) = delete;
    /// @brief Delete copy assignment
    notifySwClusterInfo& operator=(const notifySwClusterInfo& other) = delete;
    /// @brief Move constructor
    notifySwClusterInfo(notifySwClusterInfo&& other) noexcept : mInterface(other.mInterface)
    {
    }
    /// @brief Move assignment
    notifySwClusterInfo& operator=(notifySwClusterInfo&& other) noexcept
    {
        mInterface = other.mInterface;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        para::serializer::Serializer serializer{};
        serializer.write(data);
        auto payload = serializer.ensure();
        return mInterface->SendEvent(kCallSign, payload);
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    const std::string kCallSign = {"notifySwClusterInfo"};
};
/// @uptrace{SWS_CM_00003}
class notifyUpdatableApp
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = eevp::ota::subscription::type::UpdatableAppInfo;
    /// @brief Constructor
    explicit notifyUpdatableApp(para::com::SkeletonInterface* interface) : mInterface(interface)
    {
    }
    /// @brief Destructor
    virtual ~notifyUpdatableApp() = default;
    /// @brief Delete copy constructor
    notifyUpdatableApp(const notifyUpdatableApp& other) = delete;
    /// @brief Delete copy assignment
    notifyUpdatableApp& operator=(const notifyUpdatableApp& other) = delete;
    /// @brief Move constructor
    notifyUpdatableApp(notifyUpdatableApp&& other) noexcept : mInterface(other.mInterface)
    {
    }
    /// @brief Move assignment
    notifyUpdatableApp& operator=(notifyUpdatableApp&& other) noexcept
    {
        mInterface = other.mInterface;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        para::serializer::Serializer serializer{};
        serializer.write(data);
        auto payload = serializer.ensure();
        return mInterface->SendEvent(kCallSign, payload);
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    const std::string kCallSign = {"notifyUpdatableApp"};
};
/// @uptrace{SWS_CM_00003}
class notifyUpdateComplete
{
public:
    /// @brief Type alias for type of event data
    /// @uptrace{SWS_CM_00162, SWS_CM_90437}
    using SampleType = bool;
    /// @brief Constructor
    explicit notifyUpdateComplete(para::com::SkeletonInterface* interface) : mInterface(interface)
    {
    }
    /// @brief Destructor
    virtual ~notifyUpdateComplete() = default;
    /// @brief Delete copy constructor
    notifyUpdateComplete(const notifyUpdateComplete& other) = delete;
    /// @brief Delete copy assignment
    notifyUpdateComplete& operator=(const notifyUpdateComplete& other) = delete;
    /// @brief Move constructor
    notifyUpdateComplete(notifyUpdateComplete&& other) noexcept : mInterface(other.mInterface)
    {
    }
    /// @brief Move assignment
    notifyUpdateComplete& operator=(notifyUpdateComplete&& other) noexcept
    {
        mInterface = other.mInterface;
        return *this;
    }
    /// @brief Send event with data to subscribing service consumers
    /// @uptrace{SWS_CM_90437}
    ara::core::Result<void> Send(const SampleType& data)
    {
        para::serializer::Serializer serializer{};
        serializer.write(data);
        auto payload = serializer.ensure();
        return mInterface->SendEvent(kCallSign, payload);
    }
    /// @brief Returns unique pointer about SampleType
    /// @uptrace{SWS_CM_90438}
    ara::core::Result<ara::com::SampleAllocateePtr<SampleType>> Allocate()
    {
        return std::make_unique<SampleType>();
    }
    
private:
    para::com::SkeletonInterface* mInterface;
    const std::string kCallSign = {"notifyUpdateComplete"};
};
} /// namespace events
/// @uptrace{SWS_CM_01031}
namespace fields
{
} /// namespace fields
/// @uptrace{SWS_CM_00002}
class OtaSubscriptionSkeleton
{
public:
    /// @uptrace{SWS_CM_00191}
    struct requestAppInstallOutput
    {
        bool returnValue;
    };
    struct requestAppRollbackOutput
    {
    };
    struct requestAppUpdateOutput
    {
        bool returnValue;
    };
    struct requestOtaProcessOutput
    {
        bool returnValue;
    };
    struct requestVersionInfoOutput
    {
        eevp::ota::subscription::type::RequestAppInfoMap requestAppInfoMap;
        bool returnValue;
    };
    /// @brief Constructor
    /// @uptrace{SWS_CM_00002, SWS_CM_00152}
    OtaSubscriptionSkeleton(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode = ara::com::MethodCallProcessingMode::kEvent)
        : mInterface(std::make_unique<para::com::SkeletonInterface>(instanceSpec, mode))
        , notifyAppEvent(mInterface.get())
        , notifyResultInfo(mInterface.get())
        , notifyRollbackComplete(mInterface.get())
        , notifySwClusterInfo(mInterface.get())
        , notifyUpdatableApp(mInterface.get())
        , notifyUpdateComplete(mInterface.get())
    {
        mInterface->SetMethodCallHandler(krequestAppInstallCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppInstall(data, token);
        });
        mInterface->SetMethodCallHandler(krequestAppRollbackCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppRollback(data, token);
        });
        mInterface->SetMethodCallHandler(krequestAppUpdateCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppUpdate(data, token);
        });
        mInterface->SetMethodCallHandler(krequestOtaProcessCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestOtaProcess(data, token);
        });
        mInterface->SetMethodCallHandler(krequestVersionInfoCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestVersionInfo(data, token);
        });
        mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
            E2EErrorHandler(errorCode, dataID, messageCounter);
        });
    }
    /// @brief Destructor
    virtual ~OtaSubscriptionSkeleton() = default;
    /// @brief Delete copy constructor
    /// @uptrace{SWS_CM_00134}
    OtaSubscriptionSkeleton(const OtaSubscriptionSkeleton& other) = delete;
    /// @brief Delete copy assignment
    /// @uptrace{SWS_CM_00134}
    OtaSubscriptionSkeleton& operator=(const OtaSubscriptionSkeleton& other) = delete;
    /// @brief Move constructor
    /// @uptrace{SWS_CM_00135}
    OtaSubscriptionSkeleton(OtaSubscriptionSkeleton&& other) noexcept
        : mInterface(std::move(other.mInterface))
        , notifyAppEvent(std::move(other.notifyAppEvent))
        , notifyResultInfo(std::move(other.notifyResultInfo))
        , notifyRollbackComplete(std::move(other.notifyRollbackComplete))
        , notifySwClusterInfo(std::move(other.notifySwClusterInfo))
        , notifyUpdatableApp(std::move(other.notifyUpdatableApp))
        , notifyUpdateComplete(std::move(other.notifyUpdateComplete))
    {
        mInterface->SetMethodCallHandler(krequestAppInstallCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppInstall(data, token);
        });
        mInterface->SetMethodCallHandler(krequestAppRollbackCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppRollback(data, token);
        });
        mInterface->SetMethodCallHandler(krequestAppUpdateCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppUpdate(data, token);
        });
        mInterface->SetMethodCallHandler(krequestOtaProcessCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestOtaProcess(data, token);
        });
        mInterface->SetMethodCallHandler(krequestVersionInfoCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestVersionInfo(data, token);
        });
        mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
            E2EErrorHandler(errorCode, dataID, messageCounter);
        });
        other.mInterface.reset();
    }
    /// @brief Move assignment
    /// @uptrace{SWS_CM_00135}
    OtaSubscriptionSkeleton& operator=(OtaSubscriptionSkeleton&& other) noexcept
    {
        mInterface = std::move(other.mInterface);
        notifyAppEvent = std::move(other.notifyAppEvent);
        notifyResultInfo = std::move(other.notifyResultInfo);
        notifyRollbackComplete = std::move(other.notifyRollbackComplete);
        notifySwClusterInfo = std::move(other.notifySwClusterInfo);
        notifyUpdatableApp = std::move(other.notifyUpdatableApp);
        notifyUpdateComplete = std::move(other.notifyUpdateComplete);
        mInterface->SetMethodCallHandler(krequestAppInstallCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppInstall(data, token);
        });
        mInterface->SetMethodCallHandler(krequestAppRollbackCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppRollback(data, token);
        });
        mInterface->SetMethodCallHandler(krequestAppUpdateCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestAppUpdate(data, token);
        });
        mInterface->SetMethodCallHandler(krequestOtaProcessCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestOtaProcess(data, token);
        });
        mInterface->SetMethodCallHandler(krequestVersionInfoCallSign, [this](const std::vector<std::uint8_t>& data, const para::com::MethodToken token) {
            HandlerequestVersionInfo(data, token);
        });
        mInterface->SetE2EErrorHandler([this](const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter) {
            E2EErrorHandler(errorCode, dataID, messageCounter);
        });
        other.mInterface.reset();
        return *this;
    }
    /// @brief Send "OfferService" message to Communication Management
    /// @uptrace{SWS_CM_00101}
    ara::core::Result<void> OfferService()
    {
        return mInterface->OfferService();
    }
    /// @brief Send "StopOfferService" message to Communication Management
    /// @uptrace{SWS_CM_00111}
    void StopOfferService()
    {
        mInterface->StopOfferService();
    }
    /// @brief Allows the implementation providing the service method to trigger the execution of the next service consumer method call at a specific point of time
    ///        if the processing mode is set to kPoll.
    /// @note This function requires that ara::com::MethodCallProcessingMode is configured as kPoll by constructor
    /// @uptrace{SWS_CM_00199}
    ara::core::Future<bool> ProcessNextMethodCall()
    {
        ara::core::Promise<bool> promise{};
        auto ret = mInterface->ProcessNextMethodCall();
        if (ret.HasValue())
        {
            promise.set_value(ret.Value());
        }
        else
        {
            promise.SetError(ret.Error());
        }
        return promise.get_future();
    }
    /// @brief In case the call to E2E_check indicated a failed E2E check of the request message, the server application can get notified via an E2E error handler.
    /// @uptrace{SWS_CM_10470}
    virtual void E2EErrorHandler(const ara::com::e2e::E2EErrorDomain& errorCode, ara::com::e2e::DataID dataID, ara::com::e2e::MessageCounter messageCounter)
    {
    }
    
private:
    std::unique_ptr<para::com::SkeletonInterface> mInterface;
    
public:
    /// @brief Event, notifyAppEvent
    events::notifyAppEvent notifyAppEvent;
    /// @brief Event, notifyResultInfo
    events::notifyResultInfo notifyResultInfo;
    /// @brief Event, notifyRollbackComplete
    events::notifyRollbackComplete notifyRollbackComplete;
    /// @brief Event, notifySwClusterInfo
    events::notifySwClusterInfo notifySwClusterInfo;
    /// @brief Event, notifyUpdatableApp
    events::notifyUpdatableApp notifyUpdatableApp;
    /// @brief Event, notifyUpdateComplete
    events::notifyUpdateComplete notifyUpdateComplete;
    /// @brief Method, requestAppInstall
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<requestAppInstallOutput> requestAppInstall(const eevp::type::String& appName) = 0;
    /// @brief Method, requestAppRollback
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<requestAppRollbackOutput> requestAppRollback() = 0;
    /// @brief Method, requestAppUpdate
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<requestAppUpdateOutput> requestAppUpdate(const eevp::type::String& appName) = 0;
    /// @brief Method, requestOtaProcess
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<requestOtaProcessOutput> requestOtaProcess(const eevp::type::String& accessToken, const eevp::type::String& refreshToken, const eevp::ota::subscription::type::downloadPackageInfoList& downloadPackageInfo) = 0;
    /// @brief Method, requestVersionInfo
    /// @uptrace{SWS_CM_00191}
    virtual ara::core::Future<requestVersionInfoOutput> requestVersionInfo() = 0;
    
private:
    void HandlerequestAppInstall(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        eevp::type::String _appName_;
        deserializer.read(_appName_);
        auto future = requestAppInstall(_appName_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            requestAppInstallOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(output.returnValue);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            ara::core::ErrorDomain::IdType domainId = result.Error().Domain().Id();
            ara::core::ErrorDomain::CodeType errorCode = result.Error().Value();
            para::serializer::Serializer serializer{};
            serializer.write(0, true, 0, domainId);
            serializer.write(0, true, 0, errorCode);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(krequestAppInstallCallSign, retResult, retData, token);
    }
    void HandlerequestAppRollback(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        auto future = requestAppRollback();
        auto result = future.GetResult();
        if (result.HasValue())
        {
            retResult = 0;
        }
        else
        {
            ara::core::ErrorDomain::IdType domainId = result.Error().Domain().Id();
            ara::core::ErrorDomain::CodeType errorCode = result.Error().Value();
            para::serializer::Serializer serializer{};
            serializer.write(0, true, 0, domainId);
            serializer.write(0, true, 0, errorCode);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(krequestAppRollbackCallSign, retResult, retData, token);
    }
    void HandlerequestAppUpdate(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        eevp::type::String _appName_;
        deserializer.read(_appName_);
        auto future = requestAppUpdate(_appName_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            requestAppUpdateOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(output.returnValue);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            ara::core::ErrorDomain::IdType domainId = result.Error().Domain().Id();
            ara::core::ErrorDomain::CodeType errorCode = result.Error().Value();
            para::serializer::Serializer serializer{};
            serializer.write(0, true, 0, domainId);
            serializer.write(0, true, 0, errorCode);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(krequestAppUpdateCallSign, retResult, retData, token);
    }
    void HandlerequestOtaProcess(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        para::serializer::Deserializer deserializer{data};
        eevp::type::String _accessToken_;
        eevp::type::String _refreshToken_;
        eevp::ota::subscription::type::downloadPackageInfoList _downloadPackageInfo_;
        deserializer.read(_accessToken_);
        deserializer.read(_refreshToken_);
        deserializer.read(_downloadPackageInfo_);
        auto future = requestOtaProcess(_accessToken_, _refreshToken_, _downloadPackageInfo_);
        auto result = future.GetResult();
        if (result.HasValue())
        {
            requestOtaProcessOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(output.returnValue);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            ara::core::ErrorDomain::IdType domainId = result.Error().Domain().Id();
            ara::core::ErrorDomain::CodeType errorCode = result.Error().Value();
            para::serializer::Serializer serializer{};
            serializer.write(0, true, 0, domainId);
            serializer.write(0, true, 0, errorCode);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(krequestOtaProcessCallSign, retResult, retData, token);
    }
    void HandlerequestVersionInfo(const std::vector<std::uint8_t>& data, const para::com::MethodToken token)
    {
        std::uint8_t retResult{1};
        std::vector<std::uint8_t> retData{};
        auto future = requestVersionInfo();
        auto result = future.GetResult();
        if (result.HasValue())
        {
            requestVersionInfoOutput output = result.Value();
            para::serializer::Serializer serializer{};
            serializer.write(output.requestAppInfoMap);
            serializer.write(output.returnValue);
            retData = serializer.ensure();
            retResult = 0;
        }
        else
        {
            ara::core::ErrorDomain::IdType domainId = result.Error().Domain().Id();
            ara::core::ErrorDomain::CodeType errorCode = result.Error().Value();
            para::serializer::Serializer serializer{};
            serializer.write(0, true, 0, domainId);
            serializer.write(0, true, 0, errorCode);
            retData = serializer.ensure();
            retResult = 1;
        }
        mInterface->ReturnMethod(krequestVersionInfoCallSign, retResult, retData, token);
    }
    const std::string krequestAppInstallCallSign{"requestAppInstall"};
    const std::string krequestAppRollbackCallSign{"requestAppRollback"};
    const std::string krequestAppUpdateCallSign{"requestAppUpdate"};
    const std::string krequestOtaProcessCallSign{"requestOtaProcess"};
    const std::string krequestVersionInfoCallSign{"requestVersionInfo"};
};
} /// namespace skeleton
} /// namespace service
} /// namespace subscription
} /// namespace ota
} /// namespace eevp
#endif /// PARA_COM_GEN_SERVICE_INTERFACE_OTASUBSCRIPTION_SKELETON_H